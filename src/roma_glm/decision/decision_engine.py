"""Decision engine for autonomous trading logic and risk management."""

from __future__ import annotations

import asyncio
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
from decimal import Decimal

from loguru import logger

from .market_monitor import MarketAlert, AlertType
from ..agent.agent_state import Portfolio, Position, TradeDecision, TradeAction


class RiskLevel(Enum):
    """Risk levels for trading decisions."""

    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"


class SignalStrength(Enum):
    """Signal strength levels."""

    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass
class TradingSignal:
    """Trading signal generated by the decision engine."""

    symbol: str
    action: TradeAction
    signal_strength: SignalStrength
    confidence_score: float  # 0.0 to 1.0
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class RiskMetrics:
    """Risk metrics for position sizing."""

    max_position_size_percent: float = 5.0  # Max 5% of portfolio per position
    max_portfolio_risk_percent: float = 2.0  # Max 2% portfolio risk
    stop_loss_percent: float = 2.0  # 2% stop loss
    take_profit_ratio: float = 2.0  # 2:1 reward/risk ratio
    max_daily_loss_percent: float = 1.0  # Max 1% daily loss
    correlation_limit: float = 0.7  # Max correlation between positions


class DecisionEngine:
    """
    Trading decision engine with risk management and position sizing.

    Evaluates market conditions, trading signals, and risk parameters
    to make autonomous trading decisions.
    """

    def __init__(
        self,
        risk_level: RiskLevel = RiskLevel.MODERATE,
        initial_portfolio_value: float = 10000.0,
    ):
        """Initialize the decision engine."""
        self.risk_level = risk_level
        self.risk_metrics = self._get_risk_metrics_for_level(risk_level)
        self.initial_portfolio_value = initial_portfolio_value
        self.daily_pnl = 0.0
        self.daily_trades: List[TradeDecision] = []
        self.last_reset_date = datetime.now(timezone.utc).date()

        logger.info(f"DecisionEngine initialized with {risk_level.value} risk level")

    def _get_risk_metrics_for_level(self, risk_level: RiskLevel) -> RiskMetrics:
        """Get risk metrics based on risk level."""
        if risk_level == RiskLevel.CONSERVATIVE:
            return RiskMetrics(
                max_position_size_percent=2.0,
                max_portfolio_risk_percent=1.0,
                stop_loss_percent=1.5,
                take_profit_ratio=2.5,
                max_daily_loss_percent=0.5,
                correlation_limit=0.5,
            )
        elif risk_level == RiskLevel.AGGRESSIVE:
            return RiskMetrics(
                max_position_size_percent=10.0,
                max_portfolio_risk_percent=3.0,
                stop_loss_percent=3.0,
                take_profit_ratio=1.5,
                max_daily_loss_percent=2.0,
                correlation_limit=0.8,
            )
        else:  # MODERATE
            return RiskMetrics()

    async def evaluate_market_alert(
        self, alert: MarketAlert, portfolio: Portfolio
    ) -> Optional[TradingSignal]:
        """
        Evaluate a market alert and generate trading signal if appropriate.

        Args:
            alert: Market alert to evaluate
            portfolio: Current portfolio state

        Returns:
            Trading signal if action is warranted, None otherwise
        """
        try:
            signal = None

            if alert.alert_type == AlertType.PRICE_THRESHOLD:
                signal = await self._evaluate_price_threshold_alert(alert, portfolio)
            elif alert.alert_type == AlertType.PRICE_CHANGE:
                signal = await self._evaluate_price_change_alert(alert, portfolio)
            elif alert.alert_type == AlertType.VOLUME_SPIKE:
                signal = await self._evaluate_volume_spike_alert(alert, portfolio)

            if signal:
                # Apply risk management and position sizing
                signal = await self._apply_risk_management(signal, portfolio)

            return signal

        except Exception as e:
            logger.error(f"Error evaluating market alert: {e}")
            return None

    async def _evaluate_price_threshold_alert(
        self, alert: MarketAlert, portfolio: Portfolio
    ) -> Optional[TradingSignal]:
        """Evaluate price threshold alert for trading opportunities."""
        symbol = alert.symbol
        current_price = alert.current_value
        threshold = alert.threshold_value
        direction = alert.metadata.get("direction", "above")

        # Check if we already have a position in this symbol
        existing_position = portfolio.get_position(symbol)

        # Generate signal based on threshold breach and current position
        if direction == "above" and current_price > threshold:
            if not existing_position:
                # Breakout above resistance - potential buy signal
                return TradingSignal(
                    symbol=symbol,
                    action=TradeAction.BUY,
                    signal_strength=SignalStrength.MODERATE,
                    confidence_score=0.7,
                    entry_price=current_price,
                    reasoning=f"Price broke above resistance level at ${threshold}",
                    metadata={"alert_type": "breakout", "resistance_level": threshold},
                )
            else:
                # Take profit on existing position
                if existing_position.action == TradeAction.BUY:
                    return TradingSignal(
                        symbol=symbol,
                        action=TradeAction.SELL,
                        signal_strength=SignalStrength.MODERATE,
                        confidence_score=0.8,
                        entry_price=current_price,
                        reasoning=f"Take profit at resistance level ${threshold}",
                        metadata={
                            "alert_type": "take_profit",
                            "position_id": existing_position.id,
                        },
                    )

        elif direction == "below" and current_price < threshold:
            if not existing_position:
                # Dip below support - potential buy signal (dip buying)
                return TradingSignal(
                    symbol=symbol,
                    action=TradeAction.BUY,
                    signal_strength=SignalStrength.WEAK,
                    confidence_score=0.6,
                    entry_price=current_price,
                    reasoning=f"Price dipped below support at ${threshold} - buying the dip",
                    metadata={"alert_type": "dip_buy", "support_level": threshold},
                )
            else:
                # Stop loss on existing position
                if existing_position.action == TradeAction.BUY:
                    return TradingSignal(
                        symbol=symbol,
                        action=TradeAction.SELL,
                        signal_strength=SignalStrength.STRONG,
                        confidence_score=0.9,
                        entry_price=current_price,
                        reasoning=f"Stop loss triggered below support at ${threshold}",
                        metadata={
                            "alert_type": "stop_loss",
                            "position_id": existing_position.id,
                        },
                    )

        return None

    async def _evaluate_price_change_alert(
        self, alert: MarketAlert, portfolio: Portfolio
    ) -> Optional[TradingSignal]:
        """Evaluate price change alert for momentum trading."""
        symbol = alert.symbol
        percentage_change = alert.current_value
        current_price = alert.metadata.get("current_price", 0)

        # Strong momentum signals
        if abs(percentage_change) >= 5.0:  # 5% or more movement
            existing_position = portfolio.get_position(symbol)

            if percentage_change > 0:  # Positive momentum
                if not existing_position:
                    return TradingSignal(
                        symbol=symbol,
                        action=TradeAction.BUY,
                        signal_strength=SignalStrength.STRONG,
                        confidence_score=min(0.8, abs(percentage_change) / 10.0),
                        entry_price=current_price,
                        reasoning=f"Strong positive momentum: {percentage_change:.1f}% increase",
                        metadata={
                            "alert_type": "momentum_buy",
                            "percentage_change": percentage_change,
                        },
                    )
            else:  # Negative momentum
                if existing_position and existing_position.action == TradeAction.BUY:
                    return TradingSignal(
                        symbol=symbol,
                        action=TradeAction.SELL,
                        signal_strength=SignalStrength.MODERATE,
                        confidence_score=min(0.8, abs(percentage_change) / 10.0),
                        entry_price=current_price,
                        reasoning=f"Negative momentum detected: {percentage_change:.1f}% decrease",
                        metadata={
                            "alert_type": "momentum_sell",
                            "percentage_change": percentage_change,
                        },
                    )

        return None

    async def _evaluate_volume_spike_alert(
        self, alert: MarketAlert, portfolio: Portfolio
    ) -> Optional[TradingSignal]:
        """Evaluate volume spike alert for potential breakout."""
        # Volume spike analysis would require more sophisticated logic
        # For now, return None as this is a placeholder
        return None

    async def _apply_risk_management(
        self, signal: TradingSignal, portfolio: Portfolio
    ) -> Optional[TradingSignal]:
        """Apply risk management rules to the trading signal."""
        try:
            # Check daily loss limits
            if (
                self.daily_pnl
                < -self.risk_metrics.max_daily_loss_percent
                * self.initial_portfolio_value
                / 100
            ):
                logger.warning(
                    f"Daily loss limit reached. Skipping trade for {signal.symbol}"
                )
                return None

            # Calculate position size
            portfolio_value = portfolio.total_value
            max_position_value = (
                portfolio_value * self.risk_metrics.max_position_size_percent / 100
            )

            # Calculate position size based on risk
            if signal.action == TradeAction.BUY:
                signal.position_size = await self._calculate_position_size(
                    signal, portfolio, max_position_value
                )

                # Set stop loss and take profit
                if signal.entry_price:
                    stop_loss_amount = (
                        signal.entry_price * self.risk_metrics.stop_loss_percent / 100
                    )
                    signal.stop_loss = signal.entry_price - stop_loss_amount

                    take_profit_amount = (
                        stop_loss_amount * self.risk_metrics.take_profit_ratio
                    )
                    signal.take_profit = signal.entry_price + take_profit_amount

            # Check correlation with existing positions (simplified)
            if await self._check_correlation_risk(signal.symbol, portfolio):
                logger.warning(
                    f"High correlation risk for {signal.symbol}. Reducing position size"
                )
                if signal.position_size:
                    signal.position_size *= 0.5

            return signal

        except Exception as e:
            logger.error(f"Error applying risk management: {e}")
            return None

    async def _calculate_position_size(
        self, signal: TradingSignal, portfolio: Portfolio, max_position_value: float
    ) -> float:
        """Calculate optimal position size based on risk parameters."""
        # Simplified position sizing - can be made more sophisticated
        base_size = max_position_value / signal.entry_price if signal.entry_price else 0

        # Adjust based on confidence score
        adjusted_size = base_size * signal.confidence_score

        # Adjust based on signal strength
        strength_multiplier = {
            SignalStrength.WEAK: 0.5,
            SignalStrength.MODERATE: 0.75,
            SignalStrength.STRONG: 1.0,
            SignalStrength.VERY_STRONG: 1.25,
        }

        final_size = adjusted_size * strength_multiplier.get(
            signal.signal_strength, 0.75
        )

        return max(0, final_size)

    async def _check_correlation_risk(self, symbol: str, portfolio: Portfolio) -> bool:
        """Check if new position would create excessive correlation risk."""
        # Simplified correlation check - in practice would use actual correlation data
        existing_symbols = set(pos.symbol for pos in portfolio.positions)

        # For crypto, many assets are highly correlated
        # This is a simplified check - real implementation would use correlation matrix
        if len(existing_symbols) >= 3:
            return True  # Assume high correlation if many positions exist

        return False

    async def evaluate_analysis_results(
        self, analysis_results: Dict[str, Any]
    ) -> List[TradingSignal]:
        """
        Evaluate market analysis results and generate trading signals.

        Args:
            analysis_results: Results from market analysis execution

        Returns:
            List of trading signals based on analysis
        """
        signals = []

        try:
            # Extract insights from analysis results
            insights = analysis_results.get("insights", [])
            market_data = analysis_results.get("market_data", {})

            # Generate signals based on analysis insights
            for insight in insights:
                if isinstance(insight, dict):
                    signal = await self._generate_signal_from_insight(
                        insight, market_data
                    )
                    if signal:
                        signals.append(signal)

            logger.info(f"Generated {len(signals)} trading signals from analysis")
            return signals

        except Exception as e:
            logger.error(f"Error evaluating analysis results: {e}")
            return []

    async def _generate_signal_from_insight(
        self, insight: Dict[str, Any], market_data: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """Generate trading signal from a single insight."""
        # Placeholder for insight-to-signal conversion logic
        # In practice, this would parse the insight text and extract trading recommendations

        symbol = insight.get("symbol")
        sentiment = insight.get("sentiment", "neutral")
        price_target = insight.get("price_target")

        if not symbol or sentiment == "neutral":
            return None

        action = TradeAction.BUY if sentiment == "bullish" else TradeAction.SELL
        confidence = insight.get("confidence", 0.5)

        return TradingSignal(
            symbol=symbol,
            action=action,
            signal_strength=SignalStrength.MODERATE,
            confidence_score=confidence,
            entry_price=price_target,
            reasoning=f"Analysis insight: {sentiment} sentiment for {symbol}",
            metadata={"source": "analysis", "insight_id": insight.get("id")},
        )

    def record_trade(self, trade: TradeDecision) -> None:
        """Record a trade decision for tracking and risk management."""
        self.daily_trades.append(trade)

        # Update daily P&L (simplified)
        if trade.action == TradeAction.SELL and trade.status == "executed":
            # Find corresponding buy trade
            for past_trade in reversed(self.daily_trades[:-1]):
                if (
                    past_trade.symbol == trade.symbol
                    and past_trade.action == TradeAction.BUY
                ):
                    pnl = (trade.price - past_trade.price) * trade.quantity
                    self.daily_pnl += pnl
                    break

        # Reset daily tracking if it's a new day
        current_date = datetime.now(timezone.utc).date()
        if current_date != self.last_reset_date:
            self.daily_pnl = 0.0
            self.daily_trades = []
            self.last_reset_date = current_date

    def get_risk_status(self) -> Dict[str, Any]:
        """Get current risk management status."""
        return {
            "risk_level": self.risk_level.value,
            "daily_pnl": self.daily_pnl,
            "daily_trades_count": len(self.daily_trades),
            "daily_loss_limit": self.risk_metrics.max_daily_loss_percent
            * self.initial_portfolio_value
            / 100,
            "risk_metrics": {
                "max_position_size_percent": self.risk_metrics.max_position_size_percent,
                "max_portfolio_risk_percent": self.risk_metrics.max_portfolio_risk_percent,
                "stop_loss_percent": self.risk_metrics.stop_loss_percent,
                "take_profit_ratio": self.risk_metrics.take_profit_ratio,
            },
        }

    def update_risk_level(self, new_level: RiskLevel) -> None:
        """Update the risk level and associated metrics."""
        old_level = self.risk_level
        self.risk_level = new_level
        self.risk_metrics = self._get_risk_metrics_for_level(new_level)

        logger.info(f"Risk level updated from {old_level.value} to {new_level.value}")
